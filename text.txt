main.cpp


#include "observer_controls.cpp"

using namespace std;
using namespace sf;

int main(){

    RenderWindow window(VideoMode(1200, 800), "Physics Engine");
    //window.setFramerateLimit(60);

    World world(Vector(0, 9.81));

    float cameraFactor = 10.f;



     //createCircle(World &world, float radius, Vector position, Vector linearVelocity, float angle, float angularVelocity, float mass, float restitution, sf::Color color, bool isStatic)
    //createRectangle(World &world, float width, float height, Vector position, Vector linearVelocity, float angle, float angularVelocity, float mass, float restitution, sf::Color color, bool isStatic)
    Object* circle = &world.createCircle(world, 20.f, Vector(500.f, 100.f), Vector(0.f, 0.f), 0.f, 0.f, 10.f, 0.5, sf::Color::Yellow, false);

    Object* rect = &world.createRectangle(world, 150.f, 20.f, Vector(700.f, 60.f), Vector(0.f, 0.f), 0.f, 0.f, 1.f, 0.5, sf::Color::Blue, true);

    Object* downLedge = &world.createRectangle(world, 400.f, 30.f, Vector(400.f, 400.f), Vector(0.f, 0.f), 155.f, 0.f, 1.f, 0.5, sf::Color::White, true);
    Object* upperLedge = &world.createRectangle(world, 400.f, 30.f, Vector(750.f, 175.f), Vector(0.f, 0.f), 25.f, 0.f, 1.f, 0.5, sf::Color::White, true);

    world.createRectangle(world, 1000.f, 60.f, Vector(600.f, 700.f), Vector(0.f, 0.f), 0.f, 0.f, 1.f, 0.5, sf::Color::White, true);


    Clock clock;
    Clock chrm;

    while(window.isOpen()){

        write("   Delta Time: ", Vector(950.f, 15));
        write("    Step Time: ", Vector(950.f, 50));
        write("Object Count: ", Vector(950.f, 85));

        pinpoint(rect);

        float stepTime = clock.restart().asSeconds() * cameraFactor;
        float chronometre = chrm.getElapsedTime().asSeconds();

        //rect->Rotate(M_PI / 2.f * stepTime * -5);

        write(to_string(chronometre), Vector(1100.f, 15));
        write(to_string(stepTime * 1000), Vector(1100.f, 50));
        write(to_string(world.getObjects().size()), Vector(1100.f, 85));

        Event event;
        while (window.pollEvent(event)){
            
            if(event.type == Event::Closed){

                window.close(); 

            }

            spawner(event, window, world);
            
        }

        window.clear(Color::Black);

        world.update(stepTime, 5);

        for(auto& obj : world.getObjects()){

            if(obj->shape){

                window.draw(*obj->shape);

            }

        }

        showHitboxes(window, world, true);

        showContacts(world.getIndicators(), window, world, true);

        printer(window);

        window.display();

    }

    return 0;
}


#include "World.cpp"
#include <random>

using namespace sf;

void spawner(Event event, RenderWindow &window, World &world){

    if(event.type == Event::KeyPressed){

        Vector2i mousePosition = Mouse::getPosition(window);
        Vector spawnPosition(mousePosition.x, mousePosition.y);

        static std::random_device rd;
        static std::mt19937 gen(rd());
        static std::uniform_int_distribution<> colorDist(0, 255);   

        sf::Color randomColor(
            colorDist(gen),
            colorDist(gen),
            colorDist(gen)
        );

        if(event.key.code == Keyboard::Key::Num1){

            world.createCircle(world, 20.f, spawnPosition, Vector(0.f, 0.f), 0.f, 0.f, 1.f, 0.5, randomColor, false);

        } 
        else if (event.key.code == Keyboard::Key::Num2){

            world.createRectangle(world, 100.f, 50.f, spawnPosition, Vector(0.f, 0.f), 0.f, 0.f, 1.f, 0.5, randomColor, false);

        }

    }

}

std::vector<Text> texts;
Font font;

void write(String t, Vector pos, float size = 20, Color color = Color::White){

    Text text;
    text.setString(t);
    font.loadFromFile("./Assets/Fonts/worksans.ttf");
    text.setFont(font);
    text.setCharacterSize(size);
    text.setPosition(Vector2(pos.x, pos.y)); 
    text.setFillColor(Color::White);
    texts.push_back(text);

}


void printer(RenderWindow &window){

    for(auto& text : texts){

        window.draw(text);

    }

    texts.clear();

}


void pinpoint(Object* obj){

    if(!obj){

        write("Object destroyed.", Vector(5, 15));

    }else{

        write("m: ", Vector(5, 15));
        write("pos: ", Vector(5, 50));
        write("teta: ", Vector(5, 85));
        write("v: ", Vector(5, 120));
        write("a: ", Vector(5, 155));
        write("*F: ", Vector(5, 190));
        write("*P: ", Vector(5, 225));
    
        Vector accelaration = obj->force / obj->mass;
        Vector momentum = obj->linearVelocity * obj->mass;
    
        write(std::to_string(obj->mass), Vector(60, 15));
        write(std::to_string(obj->position.x) + ", " + std::to_string(obj->position.y), Vector(60, 50));
        write(std::to_string(obj->angle), Vector(60, 85));
        write(std::to_string(obj->linearVelocity.x) + ", " + std::to_string(obj->linearVelocity.y), Vector(60, 120));
        write(std::to_string(accelaration.x) + ", " + std::to_string(accelaration.y), Vector(60, 155));
        write(std::to_string(obj->force.x) + ", " + std::to_string(obj->force.y), Vector(60, 190));
        write(std::to_string(momentum.x) + ", " + std::to_string(momentum.y), Vector(60, 225));

    }



}


void createIndicator(RenderWindow &window, World& world, Vector pos){

    CircleShape* CircShape = new CircleShape(5.f); 
    CircShape->setPosition(Vector2f(pos.x, pos.y));
    CircShape->setOrigin(5, 5);
    CircShape->setOutlineThickness(3.f);     
    CircShape->setOutlineColor(Color::Red);
    CircShape->setFillColor(Color::Transparent);

    window.draw(*CircShape);

}


void showContacts(std::vector<Manifold*> indicators, RenderWindow &window, World &world, bool on){

    if(on){

        for(Manifold* ind : indicators){

            createIndicator(window, world, ind->contact1);

            if(ind->contactCount == 2){

                createIndicator(window, world, ind->contact2);

            }

        }

    }

}

void showHitboxes(RenderWindow &window, World &world, bool on){

    if(on){

        for(auto& obj : world.getObjects()){

            if(obj->shape){
        
                std::vector<Vector> verts = obj->getTransformedVertices();
    
                for(size_t i = 0; i < verts.size(); i++){
    
                    sf::CircleShape point(2);
                    point.setFillColor(sf::Color::Red);
                    point.setPosition(verts[i].x, verts[i].y);
                    window.draw(point);
    
                }
    
            }
    
        }

    }

}

#include "physics.cpp"

void World::addObject(Object* object){

    objects.push_back(object);

}

Object& World::createRectangle(World& world, float width, float height, Vector position, Vector linearVelocity, float angle, float angularVelocity, float mass, float restitution, sf::Color color, bool isStatic){

    RectangleShape* RectShape = new RectangleShape(Vector2f(width, height)); 
    RectShape->setOrigin(width / 2.0f, height / 2.0f);
    RectShape->setOutlineThickness(2.f);     
    RectShape->setOutlineColor(sf::Color::White);
    RectShape->rotate(-angle);

    Object* RectObject = new Object(0, width, height, position, linearVelocity, angle, angularVelocity, mass, restitution, RectShape, color, isStatic, 1);
    world.addObject(RectObject);

    return *RectObject;

}

Object& World::createCircle(World& world, float radius, Vector position, Vector linearVelocity, float angle, float angularVelocity, float mass, float restitution, sf::Color color, bool isStatic){

    CircleShape* CircShape = new CircleShape(radius);
    CircShape->setOrigin(radius, radius);
    CircShape->setOutlineThickness(2.f);  
    CircShape->setOutlineColor(sf::Color::White);
    CircShape->rotate(-angle);

    Object* CircObject = new Object(radius, 0, 0, position, linearVelocity, angle, angularVelocity, mass, restitution, CircShape, color, isStatic, 0);
    world.addObject(CircObject);

    return *CircObject;

}

void World::update(float stepTime, int iterations){

    stepTime /= iterations;

    for(int its = 0; its < iterations; its++){

        handleTransformations(stepTime, objects);


        for(Object*& obj : objects){

            handleGravity(stepTime, obj, gravity);
            handleCollisions(objects, obj, contactList, indicatorList);

        }

        for(Manifold* contact : contactList){

            resolveCollisionWithRotation(*contact);

        }

        //cleaning

        indicatorList = contactList;

        contactList.clear();

        for(size_t i = 0; i < objects.size();){

            if(objects[i]->position.x < -50 || objects[i]->position.y > 900 || objects[i]->position.x > 1250){

                delete objects[i];            
                objects.erase(objects.begin() + i); 

            }else{

                ++i; 

            }

        }

        objects.erase(std::remove(objects.begin(), objects.end(), nullptr), objects.end());  

    }
        
}

float World::getGravity() const{

    return gravity.y;

}

const std::vector<Object*>& World::getObjects() const{

    return objects;

}

const std::vector<Manifold*>& World::getContacts() const{

    return contactList;

}

const std::vector<Manifold*>& World::getIndicators() const{

    return indicatorList;

}



#include "utility.cpp"

void handleTransformations(float deltaTime, std::vector<Object*> objects){

    for(Object*& obj : objects){

        if(obj->isStatic) continue;

        // Wrap angle nicely
        if(obj->angle < -360.f) obj->angle += 360.f;
        if(obj->angle > 360.f) obj->angle -= 360.f;

        // Physics: Update velocity and position
        Vector acceleration = obj->force / obj->mass;
        obj->linearVelocity = obj->linearVelocity + acceleration * deltaTime;
        obj->position = obj->position + obj->linearVelocity * deltaTime;

        // ✅ Only rotate using angularVelocity delta
        obj->Rotate(-obj->angularVelocity * deltaTime);

        // Update SFML shape position (angle already applied inside Rotate)
        obj->shape->setPosition(sf::Vector2f(obj->position.x, obj->position.y));

        //obj->transformUpdateRequired = true;
        //obj->aabbUpdateRequired = true;
    }
}


void handleGravity(float deltaTime, Object* obj, Vector gravity){

    obj->force = Vector(0.f, 0.f);

    if(!obj->isStatic){

        Vector gravitationalForce = gravity * obj->mass;
        obj->force = obj->force + gravitationalForce;

    }

}


void handleCollisions(std::vector<Object*>& objects, Object* obj1, std::vector<Manifold*>& contactList, std::vector<Manifold*>& indicatorList){

    AABB aabb1 = obj1->getAABB();

    for(Object* obj2 : objects){

        AABB aabb2 = obj2->getAABB();

        if(obj1 == obj2 || (obj1->isStatic && obj2->isStatic)){

            continue; 

        }

        if(!intersectAABBs(aabb1, aabb2)){

            continue;

        }

        Vector normal;
        float depth;

       if(collide(obj1, obj2, normal, depth)){

        if(obj1->isStatic){

            obj2->Move(normal * depth);

        }
        else if(obj2->isStatic){

            obj1->Move(-normal * depth);

        }else{

            obj1->Move(-normal * depth / 2);
            obj2->Move(normal * depth / 2);

        }

        Vector contact1;
        Vector contact2;
        int contactCount;

        findContactPoints(*obj1, *obj2, contact1, contact2, contactCount);
        contactList.push_back(new Manifold(obj1, obj2, normal, depth, contact1, contact2, contactCount));

       }

    }

}


void cleaner(std::vector<Object*>& objects, Object& obj){

    for (size_t i = 0; i < objects.size();){

        if(objects[i]->position.x < -50 || objects[i]->position.y > 900 || objects[i]->position.x > 1250){

            delete objects[i];             
            objects.erase(objects.begin() + i);  

        }else{

            ++i; 

        }
    }
}





#include "utility.cpp"

void handleTransformations(float deltaTime, std::vector<Object*> objects){

    for(Object*& obj : objects){

        if(obj->isStatic) continue;

        // Wrap angle nicely
        if(obj->angle < -360.f) obj->angle += 360.f;
        if(obj->angle > 360.f) obj->angle -= 360.f;

        // Physics: Update velocity and position
        Vector acceleration = obj->force / obj->mass;
        obj->linearVelocity = obj->linearVelocity + acceleration * deltaTime;
        obj->position = obj->position + obj->linearVelocity * deltaTime;

        // ✅ Only rotate using angularVelocity delta
        obj->Rotate(-obj->angularVelocity * deltaTime);

        // Update SFML shape position (angle already applied inside Rotate)
        obj->shape->setPosition(sf::Vector2f(obj->position.x, obj->position.y));

        //obj->transformUpdateRequired = true;
        //obj->aabbUpdateRequired = true;
    }
}


void handleGravity(float deltaTime, Object* obj, Vector gravity){

    obj->force = Vector(0.f, 0.f);

    if(!obj->isStatic){

        Vector gravitationalForce = gravity * obj->mass;
        obj->force = obj->force + gravitationalForce;

    }

}


void handleCollisions(std::vector<Object*>& objects, Object* obj1, std::vector<Manifold*>& contactList, std::vector<Manifold*>& indicatorList){

    AABB aabb1 = obj1->getAABB();

    for(Object* obj2 : objects){

        AABB aabb2 = obj2->getAABB();

        if(obj1 == obj2 || (obj1->isStatic && obj2->isStatic)){

            continue; 

        }

        if(!intersectAABBs(aabb1, aabb2)){

            continue;

        }

        Vector normal;
        float depth;

       if(collide(obj1, obj2, normal, depth)){

        if(obj1->isStatic){

            obj2->Move(normal * depth);

        }
        else if(obj2->isStatic){

            obj1->Move(-normal * depth);

        }else{

            obj1->Move(-normal * depth / 2);
            obj2->Move(normal * depth / 2);

        }

        Vector contact1;
        Vector contact2;
        int contactCount;

        findContactPoints(*obj1, *obj2, contact1, contact2, contactCount);
        contactList.push_back(new Manifold(obj1, obj2, normal, depth, contact1, contact2, contactCount));

       }

    }

}


void cleaner(std::vector<Object*>& objects, Object& obj){

    for (size_t i = 0; i < objects.size();){

        if(objects[i]->position.x < -50 || objects[i]->position.y > 900 || objects[i]->position.x > 1250){

            delete objects[i];             
            objects.erase(objects.begin() + i);  

        }else{

            ++i; 

        }
    }
}




#include "World.hpp"

Vector change(Vector2f vector){

    return Vector(vector.x, vector.y);

}


float distance(Vector centerA, Vector centerB){

    return (centerA - centerB).magnitude();

}


float distanceSquared(Vector centerA, Vector centerB){

    return distance(centerA, centerB) * distance(centerA, centerB);

}


Vector findArithmeticMean(std::vector<Vector> vertices){

    float sumX = 0.f;
    float sumY = 0.f;

    for(int i = 0; i < vertices.size(); i++){

        Vector v = vertices[i];
        sumX += v.x;
        sumY += v.y;

    }

    return Vector(sumX / vertices.size(), sumY / vertices.size());

}


int findClosestPointOnPolygon(Vector circleCenter, std::vector<Vector> vertices){

    int result = -1;
    float minDist = std::numeric_limits<float>::max();

    for(int i = 0; i < vertices.size(); i++){

        Vector v = vertices[i];
        float dist = distance(v, circleCenter);

        if(dist < minDist){

            minDist = dist;
            result = i;

        }

    }

    return result;

}


std::vector<Vector> getVertices(sf::RectangleShape* rectangle){

    std::vector<Vector> vertices;

    vertices.push_back(change(rectangle->getTransform().transformPoint(0, 0)));
    vertices.push_back(change(rectangle->getTransform().transformPoint(rectangle->getSize().x, 0)));
    vertices.push_back(change(rectangle->getTransform().transformPoint(rectangle->getSize().x, rectangle->getSize().y)));
    vertices.push_back(change(rectangle->getTransform().transformPoint(0, rectangle->getSize().y)));

    return vertices;

}


void projectVertices(std::vector<Vector> vertices, Vector axis, float& min, float& max){

    min = std::numeric_limits<float>::max();
    max = std::numeric_limits<float>::min();

    for(int i = 0; i < vertices.size(); i++){

        Vector v = vertices[i];
        float projection = Vector::dot(v, axis); 

        if(projection < min) min = projection;
        if(projection > max) max = projection;

    }

}


void projectCircle(Vector center, float radius, Vector axis, float& min, float& max){

    Vector direction = axis.normalize();
    Vector directionAndRadius = direction * radius;

    Vector p1 = center + directionAndRadius;
    Vector p2 = center - directionAndRadius;

    min = Vector::dot(p1, axis);
    max = Vector::dot(p2, axis);

    if(min > max){

        float t = min;
        min = max;
        max = t;

    }

}


void pointSegmentDistance(Vector point, Vector s1, Vector s2, float& distanceSq, Vector& contact){

    Vector ab = s2 - s1;
    Vector ap = point - s1;

    float proj = Vector::dot(ap, ab);  
    float abLenSq = ab.magnitudeSquared();
    float d = proj / abLenSq;
    
    if(d <= 0.f){

        contact = s1;

    }else if(d >= 1){

        contact = s2;

    }else{

        contact = s1 + ab * d;

    }

    distanceSq = distanceSquared(point, contact);

}


void findContactPoint(Vector centerA, float radiusA, Vector centerB, Vector& contactPoint){

    Vector dir = (centerB - centerA).normalize();
    contactPoint = (centerA + dir * radiusA);

}


void findContactPoint(Vector circleCenter, float circleRadius, Vector polygonCenter, std::vector<Vector> vertices, Vector& contactPoint){

    float minDistSq = std::numeric_limits<float>::max();

    for(int i = 0; i < vertices.size(); i++){

        Vector va = vertices[i];
        Vector vb = vertices[(i + 1) % vertices.size()]; 

        float distanceSq;
        Vector contact;

        pointSegmentDistance(circleCenter, va, vb, distanceSq, contact);

        if(distanceSq < minDistSq){

            minDistSq = distanceSq;
            contactPoint = contact;

        }

    }

}


void findContactPoints(Object obj1, Object obj2, Vector& contact1, Vector& contact2, int& contactCount){

    contact1 = Vector::Zero();
    contact2 = Vector::Zero();
    contactCount = 0;

    if(obj1.type == 1){

        if(obj2.type == 1){

            findContactPoints(obj1.getTransformedVertices(), obj2.getTransformedVertices(), contact1, contact2, contactCount);

        }
        else if(obj2.type == 0){

            //CircleShape* circle = static_cast<sf::CircleShape*>(obj2.shape);
            //RectangleShape* rect = static_cast<sf::RectangleShape*>(obj1.shape);
            findContactPoint(obj2.position, obj2.radius, obj1.position, obj1.getTransformedVertices(), contact1);
            contactCount = 1;

        }

    }
    else if(obj1.type == 0){

        if(obj2.type == 1){
            
            findContactPoint(obj1.position, obj1.radius, obj2.position, obj2.getTransformedVertices(), contact1);
            contactCount = 1;

        }
        else if(obj2.type == 0){

            findContactPoint(obj1.position, obj1.radius, obj2.position, contact1);
            contactCount = 1;

        }

    }

}


void findContactPoints(std::vector<Vector> verticesA, std::vector<Vector> verticesB, Vector& contact1, Vector& contact2, int& contactCount){

    contact1 = Vector::Zero();
    contact2 = Vector::Zero();
    contactCount = 0;

    float minDistSq = std::numeric_limits<float>::max();

    for(int i = 0; i < verticesA.size(); i++){

        Vector p = verticesA[i];

        for(int j = 0; j < verticesB.size(); j++){

            Vector va = verticesB[j];
            Vector vb = verticesB[(j + 1) % verticesB.size()];

            float distSq;
            Vector cp;

            pointSegmentDistance(p, va, vb, distSq, cp);

            if(Vector::nearlyEqual(distSq, minDistSq)){

                if(!Vector::nearlyEqual(cp, contact1) && !Vector::nearlyEqual(cp, contact2)){

                    contact2 = cp;
                    contactCount = 2;

                }



            }else if(distSq < minDistSq){

                minDistSq = distSq;
                contactCount = 1;
                contact1 = cp;

            }

        }

    }

    for(int i = 0; i < verticesB.size(); i++){

        Vector p = verticesB[i];

        for(int j = 0; j < verticesA.size(); j++){

            Vector va = verticesA[j];
            Vector vb = verticesA[(j + 1) % verticesA.size()];

            float distSq;
            Vector cp;

            pointSegmentDistance(p, va, vb, distSq, cp);

            if(Vector::nearlyEqual(distSq, minDistSq)){

                if(!Vector::nearlyEqual(cp, contact1) && !Vector::nearlyEqual(cp, contact2)){

                    contact2 = cp;
                    contactCount = 2;

                }



            }else if(distSq < minDistSq){

                minDistSq = distSq;
                contactCount = 1;
                contact1 = cp;

            }

        }

    }

}


bool intersectAABBs(AABB a, AABB b){

    if(a.max.x <= b.min.x || b.max.x <= a.min.x || a.max.y <= b.min.y || b.max.y <= a.min.y){

        return false;

    }

    return true;

}


bool intersectCircles(Object* circleA, Object* circleB, Vector& normal, float& depth){

    Vector centerA = circleA->getPosition();
    Vector centerB = circleB->getPosition();
    
    float dist = distance(centerA, centerB);
    float radii = circleA->radius + circleB->radius;
    
    if(dist >= radii){

        return false;

    }

    normal = (centerB - centerA).normalize();
    depth = radii - dist;
    
    return true;

}


bool intersectPolygons(Vector centerA, std::vector<Vector> verticesA, Vector centerB, std::vector<Vector> verticesB, Vector& normal, float& depth){

    normal.Zero();
    depth = std::numeric_limits<float>::max();

    for(int i = 0; i < verticesA.size(); i++){

        Vector vA = verticesA[i];
        Vector vB = verticesA[(i + 1) % verticesA.size()];

        Vector edge = vB - vA;
        Vector axis = Vector(-edge.y, edge.x).normalize();

        float minA, maxA;
        float minB, maxB;

        projectVertices(verticesA, axis, minA, maxA);
        projectVertices(verticesB, axis, minB, maxB);

        if(minA >= maxB || minB >= maxA){

            return false;

        }

        float axisDepth = std::min(maxB - minA, maxA - minB);

        if(axisDepth < depth){

            depth = axisDepth;
            normal = axis;

        }

    }

    for(int i = 0; i < verticesB.size(); i++){

        Vector vA = verticesB[i];
        Vector vB = verticesB[(i + 1) % verticesB.size()];

        Vector edge = vB - vA;
        Vector axis = Vector(-edge.y, edge.x).normalize();

        float minA, maxA;
        float minB, maxB;

        projectVertices(verticesA, axis, minA, maxA);
        projectVertices(verticesB, axis, minB, maxB);

        if(minA >= maxB || minB >= maxA){

            return false;

        }

        float axisDepth = std::min(maxB - minA, maxA - minB);

        if(axisDepth < depth){

            depth = axisDepth;
            normal = axis;

        }

    }

    Vector direction = centerB - centerA;

    if(Vector::dot(centerB - centerA, normal) < 0.f){

        normal = -normal;

    }

    return true;

}


bool intersectCirclePolygons(Vector circleCenter, float circleRadius, Vector polygonCenter, std::vector<Vector> vertices, Vector& normal, float& depth){

    normal = Vector(0.f, 0.f);
    depth = std::numeric_limits<float>::max();

    Vector axis = Vector(0.f, 0.f);
    float axisDepth = 0.f;

    float minA, maxA;
    float minB, maxB;

    for(int i = 0; i < vertices.size(); i++){

        Vector vA = vertices[i];
        Vector vB = vertices[(i + 1) % vertices.size()];

        Vector edge = vB - vA;
        axis = Vector(-edge.y, edge.x).normalize();

        projectVertices(vertices, axis, minA, maxA);
        projectCircle(circleCenter, circleRadius, axis, minB, maxB);

        if(minA >= maxB || minB >= maxA){

            return false;

        }

        axisDepth = std::min(maxB - minA, maxA - minB);

        if(axisDepth < depth){

            depth = axisDepth;
            normal = axis;

        }

    }

    int cpIndex = findClosestPointOnPolygon(circleCenter, vertices);

    if (cpIndex == -1) return false;
    Vector cp = vertices[cpIndex];

    axis = (cp - circleCenter).normalize();

    projectVertices(vertices, axis, minA, maxA);
    projectCircle(circleCenter, circleRadius, axis, minB, maxB);

    if(minA >= maxB || minB >= maxA){

        return false;

    }

    axisDepth = std::min(maxB - minA, maxA - minB);

    if(axisDepth < depth){

        depth = axisDepth;
        normal = axis;

    }

    Vector direction = polygonCenter - circleCenter;

    if(Vector::dot(direction, normal) < 0.f){

        normal = -normal;

    }

    return true;

}


bool collide(Object* obj1, Object* obj2, Vector& normal, float& depth){

    normal = normal.Zero();
    depth = 0.f;
    
    if(obj1->type == 1){

        if(obj2->type == 1){

            return intersectPolygons(obj1->getPosition(), obj1->getTransformedVertices(),obj2->getPosition(), obj2->getTransformedVertices(), normal, depth);

        }
        else if(obj2->type == 0){

            bool result = intersectCirclePolygons(obj2->getPosition(), obj2->radius, obj1->getPosition(), obj1->getTransformedVertices(), normal, depth);

            normal = -normal;
            return result;

        }

    }
    else if(obj1->type == 0){

        if(obj2->type == 1){

            return intersectCirclePolygons(obj1->getPosition(), obj1->radius, obj2->getPosition(), obj2->getTransformedVertices(), normal, depth);

        }
        else if(obj2->type == 0){

            return intersectCircles(obj1, obj2, normal, depth);

        }

    }

    return false;


}


void resolveCollision(Manifold contact){

    Object* obj1 = contact.obj1;
    Object* obj2 = contact.obj2;
    Vector normal = contact.normal;
    float depth = contact.depth;

    Vector relativeVelocity = obj2->linearVelocity - obj1->linearVelocity;

    if(Vector::dot(relativeVelocity, normal) > 0){

        return;

    }

    float e = std::min(obj1->restitution, obj2->restitution);

    float j = -(1.f + e) * Vector::dot(relativeVelocity, normal);
    j = j / (obj1->invMass + obj2->invMass);

    Vector impulse = j * normal;

    obj1->force = obj1->force + Vector(0, -9.81);
    obj2->force = obj2->force + Vector(0, -9.81);

    obj1->linearVelocity = obj1->linearVelocity - impulse * obj1->invMass;
    obj2->linearVelocity = obj2->linearVelocity + impulse * obj2->invMass;

}


void resolveCollisionWithRotation(Manifold contact){

    Object* obj1 = contact.obj1;
    Object* obj2 = contact.obj2;
    Vector normal = contact.normal;
    Vector contact1 = contact.contact1;
    Vector contact2 = contact.contact2;
    int contactCount = contact.contactCount;

    float e = std::min(obj1->restitution, obj2->restitution);

    std::vector<Vector> contactList = {contact1, contact2};
    std::vector<Vector> impulseList;
    std::vector<Vector> r1List;
    std::vector<Vector> r2List;
    r1List.resize(contactCount);
    r2List.resize(contactCount);
    impulseList.resize(contactCount);

    for(int i = 0; i < contactCount; i++){

                impulseList[i] = Vector::Zero();
                r1List[i] = Vector::Zero();
                r2List[i] = Vector::Zero();

    }

    for(int i = 0; i < contactCount; i++){

        Vector r1 = contactList[i] - obj1->position;
        Vector r2 = contactList[i] - obj2->position;

        r1List[i] = r1;
        r2List[i] = r2;

        Vector r1Perp = Vector(-r1.y, r1.x);
        Vector r2Perp = Vector(-r2.y, r2.x);

        Vector angularLinearVelocity1 = r1Perp * obj1->angularVelocity;
        Vector angularLinearVelocity2 = r2Perp * obj2->angularVelocity;

        Vector relativeVelocity = (obj2->linearVelocity + angularLinearVelocity2) - (obj1->linearVelocity + angularLinearVelocity1);

        float contactVelocityMag = Vector::dot(relativeVelocity, normal);

        if(contactVelocityMag > 0){
    
            return;
    
        }

        float r1PerpDotN = Vector::dot(r1Perp, normal);
        float r2PerpDotN = Vector::dot(r2Perp, normal);

        float denom = obj1->invMass + obj2->invMass + (r1PerpDotN * r1PerpDotN) * obj1->invMoI + (r2PerpDotN * r2PerpDotN) * obj2->invMoI;

        float j = -(1.f + e) * contactVelocityMag;
        j = j / denom;
        j = j / contactCount;
    
        Vector impulse = j * normal;
        impulseList[i] = impulse;

    }

    for(int i = 0; i < contactCount; i++){

        Vector impulse = impulseList[i];
        Vector r1 = r1List[i];
        Vector r2 = r2List[i];

        obj1->linearVelocity = obj1->linearVelocity + -impulse * obj1->invMass;
        obj1->angularVelocity = obj1->angularVelocity + -Vector::cross(r1, impulse) * obj1->invMoI;

        obj2->linearVelocity = obj2->linearVelocity + impulse * obj2->invMass;
        obj2->angularVelocity = obj2->angularVelocity + Vector::cross(r2, impulse) * obj2->invMoI;

    }

}#ifndef WORLD_HPP
#define WORLD_HPP

#include "physics.hpp"

class World{

public:

    World(Vector gravity) : gravity(gravity) {}

    inline void addObject(Object* object);
    inline Object& createRectangle(World& world, float width, float height, Vector position, Vector linearVelocity, float angle, float angularVelocity, float mass, float restitution, sf::Color color, bool isStatic);
    inline Object& createCircle(World& world, float radius, Vector position, Vector linearVelocity, float angle, float angularVelocity, float mass, float restitution, sf::Color color, bool isStatic);   
    inline void update(float deltaTime, int iterations);

    inline float getGravity() const;
    inline const std::vector<Object*>& getObjects() const;
    inline const std::vector<Manifold*>& getContacts() const;
    inline const std::vector<Manifold*>& getIndicators() const;

private:

    Vector gravity;
    std::vector<Object*> objects;
    std::vector<Manifold*> contactList;
    std::vector<Manifold*> indicatorList;

};

#endif

#ifndef PHYSICS_HPP
#define PHYSICS_HPP

#include "utility.hpp"

inline void handleTransformations(float deltaTime, std::vector<Object*> objects);

inline void handleGravity(float deltaTime, Object* obj, Vector gravity);

inline void handleCollisions(std::vector<Object*>& objects, Object* obj1, std::vector<Manifold*>& contactList, std::vector<Manifold*>& indicatorList);

inline void cleaner(std::vector<Object*>& objects, Object& obj);

#endif


#ifndef UTILITY_HPP
#define UTILITY_HPP

#include "Manifold.hpp"

using namespace sf;

inline Vector change(Vector2f vector);

inline float distance(Vector centerA, Vector centerB);

inline float distanceSquared(Vector centerA, Vector centerB);

inline Vector findArithmeticMean(std::vector<Vector> vertices);

inline int findClosestPointOnPolygon(Vector circleCenter, std::vector<Vector> vertices);

inline std::vector<Vector> getVertices(sf::RectangleShape* rectangle);

inline void projectVertices(std::vector<Vector> vertices, Vector axis, float& min, float& max);

inline void projectCircle(Vector center, float radius, Vector axis, float& min, float& max);

inline void pointSegmentDistance(Vector point, Vector s1, Vector s2, float& distanceSq, Vector& contact);

inline void findContactPoint(Vector centerA, float radiusA, Vector centerB, Vector& contactPoint);

inline void findContactPoint(Vector circleCenter, float circleRadius, Vector polygonCenter, std::vector<Vector> vertices, Vector& contactPoint);

inline void findContactPoints(Object obj1, Object obj2, Vector& contact1, Vector& contact2, int& contactCount);

inline void findContactPoints(std::vector<Vector> verticesA, std::vector<Vector> verticesB, Vector& contact1, Vector& contact2, int& contactCount);

inline bool intersectAABBs(AABB a, AABB b);

inline bool intersectCircles(Object* circleA, Object* circleB, Vector& normal, float& depth);

inline bool intersectPolygons(Vector centerA, std::vector<Vector> verticesA, Vector centerB, std::vector<Vector> verticesB, Vector& normal, float& depth);

inline bool intersectCirclePolygons(Vector circleCenter, float circleRadius, Vector polygonCenter, std::vector<Vector> vertices, Vector& normal, float& depth);

inline bool collide(Object* obj1, Object* obj2, Vector& normal, float& depth);

inline void resolveCollision(Manifold contact);

inline void resolveCollisionWithRotation(Manifold contact);

#endif


#ifndef OBJECT_HPP
#define OBJECT_HPP

#include "AABB.hpp"
#include "Vector.hpp"
#include "Transform.hpp"
#include <vector>
#include <limits>
#include <algorithm>
#include <stdexcept>

class Object {
public:

    float radius;
    float width;
    float height;

    Vector position;
    Vector linearVelocity;
    float angle;
    float angularVelocity;

    Vector force;

    float restitution;
    sf::Shape* shape;
    sf::Color color;
    bool isStatic;
    int type;

    float mass;
    float invMass;
    float MoI;
    float invMoI;

    float density;

    std::vector<Vector> vertices;
    std::vector<Vector> transformedVertices;
    AABB aabb;
    bool transformUpdateRequired;
    bool aabbUpdateRequired;

    Object(float radius, float width, float height, Vector position, Vector linearVelocity, float angle, float angularVelocity, float mass, float restitution,
        sf::Shape* shape, sf::Color color, bool isStatic, int type)
        : radius(radius), width(width), height(height), position(position), linearVelocity(linearVelocity),
          angle(angle), angularVelocity(angularVelocity), force(Vector::Zero()), mass(mass), restitution(restitution), isStatic(isStatic), shape(shape), color(color), type(type),
          transformUpdateRequired(true), aabbUpdateRequired(true){

        MoI = getMomentOfInertia();

        if(isStatic){

            invMass = 0;
            invMoI = 0;

        }else{

            invMass = 1.f / mass;
            invMoI = 1.f / MoI;

        }

        if(type == 1){ 

            vertices = createBoxVertices(width, height);
            transformedVertices.resize(vertices.size());
            density = mass / (width * height);

        }else{

            vertices.clear();
            transformedVertices.clear();

            density = mass / (M_PI * radius * radius);

        }

        if(shape){
            
            shape->setPosition(sf::Vector2f(position.x, position.y));
            shape->setFillColor(color);

        }

    }

    Vector getPosition(){

        return Vector(shape->getPosition().x, shape->getPosition().y);

    }

    float getMomentOfInertia(){

        if(type == 0){

            return 0.5 * mass * radius * radius;

        }else{

            return (1.f/12.f) * mass * (height * height + width * width);

        }

    }

    void Move(const Vector& v){

        position = position + v;
        transformUpdateRequired = true;
        aabbUpdateRequired = true;

    }

    void MoveTo(const Vector& v){

        position = v;
        transformUpdateRequired = true;
        aabbUpdateRequired = true;

    }

    void Rotate(float amount){

        angle += amount;
        shape->rotate(-amount);
        std::cout << "Angle: " << angle << ", Angular Velocity: " << angularVelocity << "\n";

        transformUpdateRequired = true;
        aabbUpdateRequired = true;

    }

    std::vector<Vector> createBoxVertices(float width, float height) const {
        float left = -width / 2.f;
        float right = left + width;
        float bottom = -height / 2.f;
        float top = bottom + height;

        return {
            Vector(left, top),
            Vector(right, top),
            Vector(right, bottom),
            Vector(left, bottom)
        };
    }

    std::vector<Vector> getTransformedVertices(){

        if(transformUpdateRequired){

            Modify modify(position, angle);

            for (size_t i = 0; i < vertices.size(); ++i){

                transformedVertices[i] = TransformUtils::ApplyTransform(vertices[i], modify);

            }

            transformUpdateRequired = false; 

        }

        return transformedVertices;
    }

    AABB getAABB(){

        if (aabbUpdateRequired){

            float minX = std::numeric_limits<float>::max();
            float minY = std::numeric_limits<float>::max();
            float maxX = std::numeric_limits<float>::lowest();
            float maxY = std::numeric_limits<float>::lowest();
    
            if (type == 1){

                std::vector<Vector> vertices = getTransformedVertices();
    
                for (size_t i = 0; i < vertices.size(); i++){

                    Vector v = vertices[i];
    
                    if(v.x < minX) {minX = v.x;}
                    if(v.x > maxX) {maxX = v.x;}
                    if(v.y < minY) {minY = v.y;}
                    if(v.y > maxY) {maxY = v.y;}

                }

            }else if(this->type == 0){
                
                minX = this->position.x - this->radius;
                minY = this->position.y - this->radius;
                maxX = this->position.x + this->radius;
                maxY = this->position.y + this->radius;

            }
    
            aabb = AABB(minX, minY, maxX, maxY);
            aabbUpdateRequired = false;

        }
    
        return aabb;
    }
    

};

#endif
#ifndef TRANSFORM_HPP
#define TRANSFORM_HPP

#include "Vector.hpp"
#include <cmath>

class Modify {
public:
    float positionX;
    float positionY;
    float sinAngle;
    float cosAngle;

    static const Modify Zero;

    Modify(const Vector& position, float angle)
        : positionX(position.x),
          positionY(position.y),
          sinAngle(std::sin(-angle * M_PI / 180)),
          cosAngle(std::cos(-angle * M_PI / 180)) {}

    Modify(float x, float y, float angle)
        : positionX(x),
          positionY(y),
          sinAngle(std::sin(angle)),
          cosAngle(std::cos(angle)) {}
};

inline const Modify Modify::Zero = Modify(0.f, 0.f, 0.f);

namespace TransformUtils {
    inline Vector ApplyTransform(const Vector& v, const Modify& modify) {
        return Vector(
            (modify.cosAngle * v.x - modify.sinAngle * v.y) + modify.positionX,
            (modify.sinAngle * v.x + modify.cosAngle * v.y) + modify.positionY
        );
    }
}

#endif

#ifndef AABB_HPP
#define AABB_HPP

#include "Transform.hpp"

class AABB{

public:

    Vector min;
    Vector max;

    AABB() : min(Vector(0, 0)), max(Vector(0, 0)){}

    AABB(Vector min, Vector max) : min(min), max(max){}

    AABB(float minX, float minY, float maxX, float maxY){

        this->min = Vector(minX, minY);
        this->max = Vector(maxX, maxY);

    }

};

#endif #ifndef MANIFOLD_HPP
#define MANIFOLD_HPP

#include "Object.hpp"   

class Manifold{

public:

    Object* obj1;
    Object* obj2;
    const Vector normal;
    const float depth;
    const Vector contact1;
    const Vector contact2;
    const int contactCount;

    Manifold(Object* obj1, Object* obj2, 
             const Vector& normal, float depth, 
             const Vector& contact1, const Vector& contact2, int contactCount)
        : obj1(obj1), obj2(obj2), 
          normal(normal), depth(depth), 
          contact1(contact1), contact2(contact2), contactCount(contactCount){}

};

#endif 

#ifndef VECTOR_HPP
#define VECTOR_HPP

#include <iostream>
#include <limits>
#include <SFML/Graphics.hpp>

class Vector{

    public:

        float x;
        float y;

        Vector(float x = 0, float y = 0) : x(x), y(y){}

        Vector operator-() const{

            return Vector(-x, -y);

        }

        Vector operator+(const Vector& other) const{

            return Vector(x + other.x, y + other.y);

        } 

        Vector operator+(float scalar) const{

            return Vector(x + scalar, y + scalar);

        }

        friend Vector operator+(float scalar, const Vector& vec){

            return Vector(vec.x + scalar, vec.y + scalar);

        }

        Vector operator-(const Vector& other) const{

            return Vector(x - other.x, y - other.y);

        }

        Vector operator*(const Vector& other) const{

            return Vector(x * other.x, y * other.y);

        }

        Vector operator*(float scalar) const{

            return Vector(x * scalar, y * scalar);

        }

        friend Vector operator*(float scalar, const Vector& vec){

            return Vector(vec.x * scalar, vec.y * scalar);

        }

        Vector operator/(float scalar) const{

            return Vector{x / scalar, y / scalar};

        }

        bool operator==(const Vector& other) const{

            return (x == other.x && y == other.y);

        }

        bool operator!=(const Vector& other) const{

            return (x != other.x || y != other.y);
            
        }

        friend std::ostream& operator<<(std::ostream& os, const Vector& vec){

            os << vec.x << ", " << vec.y;
            return os;
            
        }

        static float radToAngle(float rad){

            return rad * 180 / M_PI;

        }

        static float angleToRad(float angle){

            return angle * M_PI / 180;

        }

        static bool nearlyEqual(float a, float b, float threshold = 0.0005f){

            return std::fabs(a - b) <= threshold;

        }
    
        static bool nearlyEqual(const Vector& v1, const Vector& v2, float threshold = 0.0005f){

            return nearlyEqual(v1.x, v2.x, threshold) && nearlyEqual(v1.y, v2.y, threshold);

        }

        float magnitude() const{

            return sqrt(x * x + y * y);

        }

        float magnitudeSquared() const{

            return x * x + y * y;

        }

        Vector normalize() const{

            float mag = magnitude();
            return mag > 0 ? Vector(x / mag, y / mag) : Vector(0,0);

        }

        float static dot(Vector a, Vector b){

            return a.x * b.x + a.y * b.y;

        }

        float static cross(Vector a, Vector b){

            return a.x * b.y - a.y * b.x;

        }

        Vector min(const Vector& other) const{

            if(this->magnitude() > other.magnitude()){

                return other;

            }else{

                return *this;

            }

        }

        Vector max(const Vector& other) const{

            if(this->magnitude() < other.magnitude()){

                return other;

            }else{

                return *this;

            }

        }

        static Vector Zero(){

            return Vector(0.f, 0.f);

        }

};

#endif